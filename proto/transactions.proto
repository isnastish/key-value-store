syntax = "proto3";
package transactions;

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/struct.proto";

enum TxnType {
    TXN_PUT = 1;
    TXN_GET = 2;
    TXN_DEL = 3;
    TXN_INCR = 4;
    TXN_INCR_BY = 5;
}

message TxnBase {
    string txnType = 1;
    google.protobuf.Timestamp timestamp = 2;
    string key = 3;
}

message IntTxn {
    TxnBase base = 1;
    int32 value = 2; 
}

message FloatTxn {
    TxnBase base = 1;
    float32 value = 2;
}

message StrTxn {
    TxnBase base = 1;
    string value = 2;
}

message MapTxn {
    TxnBase base = 1;
    google.protobuf.Struct data = 2; // map<string, string> data = 2;
}

service TransactionService {
    rpc WriteIntTxn(IntTxn) returns (google.protobuf.Empty);
    rpc WriteFloatTxn(FloatTxn) returns (google.protobuf.Empty);
    rpc WriteStrTxn(StrTxn) returns (google.protobuf.Empty);
    rpc WriteMapTxn(MapTxn) returns (google.protobuf.Empty);
}

// NOTE: Reading transactions would be more involved,
// since all the logic will be isolated into a separate service (TransactionService).
// When the KVS service starts up, the first thing it should do is to read all the transactions.
// Invoke rpcs which read the transactions from postgresql server and return them back to kvs service
// over http2 protocol.
// We will get to that problem later once writing transactions is supported.
